---
layout: post
title: 闭包学习
description: 从最简单的例子开始，一步步深入理解闭包的内部机制
category: Javascript
tags: [Javascript]
---

##渐入闭包
例一：假设有个需要，写个动态生成HTML的函数，HTML 有一部分是固定的。

* 方案1

		function buildHtml(args) {
			var template = ['<table><tr><td>',
				'',
				'</td><td>',
				'',
				'<td></td></tr></table>'];
			template[1] = args[0];
			template[3] = args[1];
			return template.join('');
		}

分析下，执行函数时，先定义template，执行完销毁template，多次执行就多次重复定义和销毁，这样肯定对性能不好，考虑把template变量放到生成Html函数的外面，改造后成了这样

* 方案2

		//...
		var template = ['<table><tr><td>',
			'',
		'</td><td>',
			'',
			'<td></td></tr></table>'];
		function buildHtml(args){
			template[1] = args[0];
			template[3] = args[1];
			return template.join('');
		}
		//...这里可以调用上面的代码


当其它页面或模块也需要这个生成Html函数时，拷贝相关代码时，但要保证template变量名和buildHtml函数名不能与已有的命名空间冲突，这层顾虑让你移动时小心翼翼，还可以这样实现

* 方案3

		//...
		buildHtml.template = ['<table><tr><td>',
			'',
			'</td><td>',
			'',
			'<td></td></tr></table>'];
		function buildHtml(args){
			var template = buildHtml.template;
			template[1] = args[0];
			template[3] = args[1];
			return template.join('');
		}
		//...这里可以调用上面的代码

* 方案4

		var buildHtml = (function(){
		var template = ['<table><tr><td>',
			'',
			'</td><td>',
			'',
			'<td></td></tr></table>'];
			return function(args){
				template[1] = args[0];
				template[3] = args[1];
				return template.join('');
			}
		})();

方案3和方案4都只用考虑其中一个变量名是否冲突。方案4 结构更紧凑，且template私有化，外面无法访问，这里就用到了闭包。
注：

	(function(){...})()
是定义一个函数，然后立即执行。

##闭包定义
一般函数在执行完后，其中的局部变量就会被销毁，方案4在执行完外部函数后，局部变量template并没销毁，这是闭包作用的结果，闭包提供了一个接口，来访问和修改函数内的局部变量、局部函数。在方案四中，执行外部函数后返回一个对象给buildHtml变量，通过buildHtml这个接口来访问和修改函数内的局部变量template。闭包实现了局部变量的维持，在函数外还可以访问修改函数内的局部变量。方案四通过return将内部引用暴露给外部，当然还有其它途径，比如在函数内部将内部函数赋给全局变量，全局变量可以是未经var声明而即时产生的，也可能是传入的实参，如例四。

至此，来总结下什么是闭包？
在一个函数（这里称为父函数）内部定义一个函数（内部函数通过作用域链访问父函数的局部变量），结束时父函数返回内部函数的引用，或者在定义的时候将内部函数引用暴露出来。执行父函数时，取得了内部函数的引用，执行完父函数后，父函数相关变量所占据的内存仍保留着，仍可以通过闭包访问和修改。
闭包从用途上来看，如同提供了一个活动的键值对列表，然后在执行内部函数时访问。闭包是内部函数定义时孕育，在外部函数执行时形成。

例三：

	function wrapFns (){
		var arr = [];
		for(var i = 10;i--;){
			arr[i] = function(){
				return i;
			}
		}
		return arr;
	}
	var fns = wrapFns();
	console.log(fns[10]()); // 值是多少？
这个例子只是加深对闭包的理解。体现为什么是“活”的。
值为0并不是10。当然这里你要它为10，也有方法，这里就不说了。

##闭包的应用
1. 正如/Users/sprying/workspace/git/sprying.github.io/_posts/2013-10-27-闭包学习.md开始所举的例子，闭包用来封装插件
例四：你在网络上download一个js插件，基本上所有插件都用到下面类似结构来实现封装，这样实现变量私有化，且还可以在外面调用或改变私有变量值

		(function(window,undefined){
			window.ymPrompt = {}; // 
		})(window);
2. 闭包来实现记忆功能

		function aa(num){
			if(num == 0){
				return 1;
			}
			return num * aa(num-1);
		}
改造后

		var aa = (function () {
			var cache = [];
			return function (num) {
				if (!cache[num]) {
					if (num == 0) {
						cache[num] = 1;
					}
					cache[num] = num * aa(num - 1);
				}
				return cache[num];
			}
		})();
类似的，可考虑用闭包实现一种类似情形，“传入一个函数，返回一个带记忆功能函数”，可参考《权威指南》P.199

3. 其它等等

毕竟在标识符前"_"仍是可以被访问的。
对象也有私有的属性和方法，我们一般用_前缀命名，但仍能被外面调用。用闭包还常见于实现定义对象的私有属性和私有方法。

	var win = (function(){
		var fn1 = function(){},//私有方法
		pro = 1;//私有属性
		return {
			outFns1:function(){
				//调用fn1或pro
			},
			outFns2:function(){
				//调用fn1或pro
		   }
		}
	})();

##闭包的内部机制
为什么函数的局部变量会被维持？闭包的内部机制是怎样的？函数嵌套很多层时的闭包是怎样的？有兴趣的可以看看下面介绍，也可以直接跳过这块。

###闭包的存亡过程
1. 函数也是对象，有[[scope]]属性（只能通过JavaScript引擎访问），指向函数定义时的执行环境上下文。--闭包就在这孕育的。
2. 假如A是全局的函数，B是A的内部函数。执行A函数时，当前执行环境的上下文指向作用域链的第一个对象是当前函数的活动对象（this、参数、局部变量），第二个对象是全局window。
3. 当执行代码运行到B定义地方， 将当前执行环境的上下文值设置给函数B的[[scope]]属性。
4. 执行A函数完毕后，若引用没外暴，A函数活动对象将被Js垃圾回收处理；反之，则维持。
5. 调用函数B时，JavaScript引擎将当前执行环境入栈（可查看IE调试器中的调用堆栈），生成新的执行环境，新的执行环境的上下文指向一个作用域链（由当前活动对象+函数B的[[scope]]组成），链的第一个对象是当前函数的活动对象（this、参数、局部变量组成），第二个活动对象是A函数产生的，第三个window。
6. B函数里面访问一个变量，要进行标志符解析（JavaScript原型也有标识符解析），它从当前上下文指向的作用域链的第一个对象开始查找，找不到就查找第二个对象，直到找到相关值就立即返回，如果没找到，报undefined错误。
7. 当有关A函数的内部引用全部被消除时，A的活动对象才被销毁。

如果A函数仅定义了B函数，然后执行它，并没有B函数引用外暴。A函数执行完毕后，A所占据的内存就此回收。如果B函数引用给外部，它的[[scope]]中的活动对象，比如父函数A的活动对象会被维持，当B函数再次调用时，仍然可以访问。--闭包就在这产生的。

##作用域链临时变更情况
- 如使用with(obj){}，try{}catch(obj){}，会将obj添加到作用域链的首部，其它活动对象相应后移一位，直到with结束。
- 使用Function定义的函数对象，函数对象的[[scope]]属性置为window。

由于我看的大多是翻译的外文，一些概念变来变去的，描叙的可能不准确。

##闭包注意点 
就如最开始举的例子，不小心忘了给函数加上var ，就产生了闭包，外部函数里面的局部变量得不到释放，如果是富客户端应用，比如你点击了页面的一个控件，通过一系列程序逻辑，调用了嵌套很深的函数，在一层层调用时，产生了一系列闭包，长期积累，内存消耗越来越大，页面反应越来越慢。
总之，如果对JavaScript语法没有个很深入了解，很容易产生闭包，导致性能问题。比如我们平时的项目开发中，基本还是基于面向过程的编程，每个功能定义个函数，然后按大功能组装在一起，大功能再按大功能组装在一起，编码没遵循常用JavaScript规范。

1、由于闭包使变量长期占据内存，所以不要随便使用闭包，注意意外引入闭包。
一个这样的构造函数

	function Construtor(){
		var aa;
		this.aa = '1';
		this.fun1 = function(){};
		this.fun2 = function(){};
		this.fun3...
	}
在fun1 fun2 fun3中没有使用aa，没有必要用闭包，Construtor.prototype.fun1 = function(){}
退一步讲，即使要使用aa，可将其命名为this.aaa，然后this.aaa访问。

2、我们使用闭包时，可以将不需继续调用局部变量在父函数末尾置为null。

##this
其实很简单，记住一点。
执行时，看函数所属是对象还是一个单独的函数？单独的函数this===window;对象方法，this == 对象。

	function UseThis(){
		console.log(this === window);
		this.instancePro = 1;
	}
	UseThis.objPro = 2;
	UseThis.objMethod = function(){
		console.log(this.objPro);
	}
	UseThis();//true 不管嵌套多深，执行函数时，函数内的this === window
	console.log(instancePro);// 1
	var useThis = new UseThis();//false 当前是A是个构造函数，构造函数内的this，是new创建的实例
	console.log(useThis.instancePro);// 1
	UseThis.objMethod();//1 当前函数是对象方法，this===A
	var fn = UseThis.objMethod;
	fn();//undefined

##总结几点
- 一个函数能访问什么变量，取决于它定义时所处的代码位置的上下文环境，而不是执行时上下文环境。
- 闭包保持私有变量不销毁，提供了访问和修改私有属性的方法。
- this很简单。

