---layout: posttitle: 提升页面的渲染速度description: category: Javascripttags: [Javascript,前端性能优化]---页面性能跟哪些有关系呢？1. 服务器提供资源、2. Http请求（缓存机制，涉及构建与部署服务这块）、3. 浏览器网页的渲染机制、4. Js单线程原理、如何提供Js代码效率5. 、、、接下来我讨论的是前两条,注意：不同浏览器的优化在有些方面有差异。##减少请求数1. 合并Js文件。编译时合并，在ant配置文件中，执行时合并，如使用combo，例子。但也注意，长时间请求一个大的Js使用户的交互体验变动糟糕。2. 使用MXHR，将css、图片、js资源整合成一个文件请求，程序后台使用分隔符将这些数据分隔开来，然后在前台拆分；还可以readystatus=3边传输边解析。缺点是，不能缓存（有点疑问，XMR的get请求可以缓存的啊）；老版本的Ie不支持readystatus =3和data:url，在Ie8中就可以了，必须在Ie6、7下设法变通。觉得在淘宝，浏览商品许多图片时，用这个不错，不过淘宝商品的图片，不在当前发起请求文档的同个域名下，有跨域问题吧。3. 一些背景图片合并成一个图片，页面利用定位显示。4. 利用缓存，减少请求，max-age设置缓存时，可能面临更新应用时，没能及时得到反馈。比如你设置某个Js的超时时间为1天，但是你在前半天更新了应用，这样客户端浏览器就无法及时更新到最新版。解决方案是：当文件内容变动时，加时间戳、或版本号。这里说下，以前做基于Ie产品时，有时涉及更新Js不生效，测试门一边在Ie调试器中清除doman缓存等，一边重启浏览器。这源于IE的缓存不像其它浏览器那么听话。IE7+,opera  如果src是一个静态不变的地址.则 不会再发起请求(无视http缓存相关头域).而直去取缓存文件 。 而且是完全不走network 模块的那种.  所以甚至httpWatch也不会抓到 cache 的项。重启浏览器就行了。## 减少流量大小1. 压缩文件YUI Compressor，引入jar，在ant的xml里面加入配置；Google的Closure Compiler。2. gzip压缩减少流量，改善用户体验，与搜索引擎有着特殊关系3. 设置返回http头信息：ETag、last-modified##无阻塞的脚本1. 采用script标签的defer属性，当页面解析到script标签时，开始下载Js文件，页面并不等待继续解析，不会阻碍其它页面资源的下载，由于只有 Explorer 4+ 和 Firefox 3.5+支持，这里就不详细讨论。2. 动态脚本注入（dynamic script tag insert）在body闭合标签处，通过Js的Dom操作，新建script元素，设置好src之后，添加到head中（最好是head,body中可能），就开始下载，不会影响浏览器UI线程，下载完触发script标签的onload事件（不同浏览器有差异），如果创建多个script后并行下载，有可能后增的Js先下载完成，有的浏览器会等待，比如FireFox、Opera，有的先下载完先执行。对于有依赖关系的Js文件，可以在前一个Js下载完成后，再加载新的Js。目前豆瓣的do.js、in.js都根据这个原理实现的封装。3. XMLHttpRequest注入在项目里，我们俗称ajax，请求的路径改为一个js的url,在返回成功的回调里面，进行Dom操作，创建一个script，将请求得到的响应报文，设置为scritpt的dom对象的text属性。评析：不能请求跨域的js，设置text属性后，立马就执行Js，所以通过控制设置text属性的时机，来控制Js的执行。不过这种方法还是被很少用，可能是将js内容直接填充到html页面的script元素中，总人本能觉得不整洁吧。##其它方案1. get/postget请求可以被缓存，但在它的请求url的长度在IE中受限，能传的参数不能太多，一次传一个报文。post的请求内容长度没有受限，分为两个数据包发送，一般此请求多用来改变服务器状态（比如插入数据）。2. 不要将内联script放在link外链css下面，css下载会阻塞js的执行，而js的阻塞，又会阻塞下面资源的加载。按google说法，把内联的script放在所有下载资源后面；天猫放在最上面。尽量合并script标签，不管是内联还是外链，因为解析标签也耗费时间。3. cdn4. Js文件放在body闭合标签处。现在的浏览器Js下载是并行的（IE8、Firefox3、Chrome2是串行），下载时会阻止页面一些资源加载（google说下载、解释、执行都会阻止），如图片；执行是阻塞浏览器的页面的下载和渲染，且所以引入的Js要放在页末。Ps:css文件下载是并行的，不阻碍其它文件下载。另外Js基本都用来操作Dom的，所以代码的执行要等Dom渲染完成，当然除非你的Js代码都是事件触发后执行，事件绑定也是在相应标签内部，不然把Js代码放在head内Js会有问题。5. 不要在外链中使用document.write加载资源6. 不要在外链中使用@import css，不能平行下载7. 将多个资源请求，拆分到多个域名下，浏览器对域名的连接数有限制；但cdn会自动拆分到多个域名。一般js不是平行下载，特殊考虑。多个域名间的资源要保持平均值。8. 静态资源，部署在无cookie的服务上。但是比如天猫要调用淘宝的推荐js，这时估计就要cookie了。这样可以保持1个报文传输。9. 图片要声明width和height <img width="" height="" src=""> 尽快渲染出，避免重排与重绘。10. body里面不要放link样式或style11. Http请求要保持Keep-Alive12. doc 返回编码charset=uft-8，加快解析；不要在html中设置，貌似ie8下有bug。##数据传输###接收数据* xhr * 动态脚本注入json-p(adding)* MXhr###发送数据信标，简单效率高，蘑菇街首页最下面的代码，就是来发送日志###数据格式xml、Json、拼接的字符串、json-p###数据的本地存储XHR请求时，设置请求头的Expires##其它知识###动态脚本注入	function loadScript(url, callback) {	   var script = document.createElement('script')	   script.type = 'text/javascript';		   if (script.readyState) { //for ie	       script.onreadystatechange = function() {	           if (script.readyState == 'loaded' || script.readyState == 'complete') {	               script.onreadystatechange = null;	               callback();	           }	       };	   } else { //other browser	       script.onload = function() {	           callback();	       };	   }		   script.src = url;	   document.getElementsByTagName('head')[0].appendChild(script);	}调用	//单个文件	loadScript('file1.js', function(){	   alert('loaded!');	});			//多个文件	loadScript('file1.js', function(){	   loadScript('file2.js',function(){	       loadScript('file3.js', function(){	           alert('all files loaded!');	       });	   });	});####其它组件* YUI3的方式* LazyLoad（1.5k）https://github.com/rgrove/lazyload* LABjs（4.7k）http://labjs.com/* SeaJS（7.5k）http://seajs.com/docs/* do 框架（3.5k）https://github.com/kejun/Do###一些常见的状态码Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别`1XX` 提示信息 - 表示请求已被成功接收，继续处理`2XX` 成功 - 表示请求已被成功接收，理解，接受`3XX` 重定向 - 要完成请求必须进行更进一步的处理`4XX` 客户端错误 -  请求有语法错误或请求无法实现`5XX` 服务器端错误 -   服务器未能实现合法的请求**`200` OK**`302` Found 重定向url**`304` Not Modified**`400` Bad Request  客户端请求与语法错误，不能被服务器所理解`403` Forbidden 服务器收到请求，但是拒绝提供服务**`404` Not Found 请求资源不存在（输错了URL）**`500` Internal Server Error 服务器发生了不可预期的错误`503` Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常这里不考虑第一次加载网页时，引用了很多公用的js，后面的网页的js请求大部分是从缓存里面取。###Js加载到浏览器中有几种方式①、通过script标签指定src②、通过script标签中的Js代码③、通过事件`<input onclick="alert(1);"/>`④、通过url`<a href='javascript:void(0)'/>`⑤、通过document.write⑥、通过ajax（还没试过）xmlhttprequest ###document.write	document.write('<script type="text/javascript" src="scripts/jquery-1.4.4.js">');	写到页面之后，就开始加载标签内容。但是在IE下，会有点不一样	<script type="text/javascript">	    document.write('<script type="text/javascript" src="a.js">');	    document.write('<script type="text/javascript">alert(a);</script>');	</script>其中a.js内容    var a = '我是在a.js中定义的';会报错，IE中write第一行之后，并没有立即加载a.js，而是开始执行第二句。于是报错了，其它浏览器正常。如何解决呢？html解析器是一个标签一个标签地解析，于是	 <script type="text/javascript">	    document.write('<script type="text/javascript" src="a.js">');	</script>   	 <script type="text/javascript">	    document.write('<script type="text/javascript">alert(a);</script>');	</script>	###Js函数定义执行上面说到并行下载，如果第二个Js文件小，比第一个Js先下载完成，这时要等第一个Js下载完，再按序执行。1、变量声明的先后	 <script type="text/javascript">	         fns();	</script>   	 <script type="text/javascript">	         function fns(){	                alert(1);	        }	</script>	这样会报错，同理，放在不同js引入，也会报错。下面就正常了	<script type="text/javascript">	       fns();	       function fns(){	              alert(1);	      }	</script> ##性能测试工具工具也有很多问题，有些具体问题具体情况没考虑到，关键要有自己的思考。* [Yslow](http://yslow.org/) 最近使用，发现启动不了，重启电脑就好了。要修复的问题，分成A、B、C、D、E、F。有些东西不准确，比如它建议把动态注入的脚本放到页末。* [Page speed](http://developers.google.com/speed/pagespeed/insights/)许多提升性能建议不错。* [阿里测](http://alibench.com/)很方便看瀑布流，看路由等IP,只能选Ie浏览器测，经常要排队。* [其它](http://www.cnblogs.com/fo0ol/p/3297054.html) 里面有阿里测使用说明## 参考文章* http://wlog.cn/javascript/javascript-load-optimization.html* 《高性能Javascript》* https://developers.google.com/speed/## 后续提高* [浏览器渲染原理](http://taligarsiel.com/Projects/howbrowserswork1.htm)，主要了解页面集中线程关系* [chrome调试](https://developers.google.com/chrome-developer-tools/?hl=zh-CN)* [Google的优化建议](https://developers.google.com/speed/)##实践###利用ant合成与压缩的方案[链接](http://www.cnblogs.com/catprayer/archive/2011/08/03/2126719.html)###个税中提升性能建议* 页面插件的统一管理，简洁代码，改造从外部引用插件整体结构，剔除每个插件中重复的方法，避免变量名冲突，培养编码人员有前端统一开发的意识。* 页面引入Js的方式改变，后台动态生成的数据Js文件，有的文件量很大，可考虑动态脚本注入方式。我随便打开一个存储数据的Js，就有40K多大小。页面加载时，必须等待这40K下载完成，才会继续。* 页面首部的许多公用Js，写成一个可配置Js文件，通过document.write方式写出，这样页面只需通过一个script引入公用Js文件，至于要引入哪些公用Js文件，可通过配置实现，方便编码开发，另外也可以防止Js文件排序错误。（goolge不推荐这种写法，因为最新的浏览器的speculative parsers 发现不了这个js...）* 部署服务时，对于Js和css文件采用gzip压缩，可减少网络数据传输量能达到一半以上。* 部署服务时，对于一些常用的Js和css采用缓存机制。浏览器自带的缓存，每次读取文件时发起请求，请求发现内容没变动，才在浏览器缓存中读取。这里所说的缓存机制，需要在weblogic端部署，设置超时时间，在这个时间内，不会发起请求，直接从缓存中读取，少了这个发起请求，可以大量减少加载文件的时间。目前基本上所有大型网站都这样做。设置缓存时，可能面临更新应用时，没能及时得到反馈。比如你设置某个Js的超时时间为1天，但是你在前半天更新了应用，这样客户端浏览器就无法及时更新到最新版。解决方案是：当文件内容变动时，加时间戳、或版本号。Ps：相关文件